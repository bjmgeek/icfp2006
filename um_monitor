#!/usr/bin/env python
'''um_monitor
allow multiple processes to interact with a single running UM instance.

usage: um_monitor um_file [session]

where um_file is a UM binary. 
If a UM session is not running, one will will be started.  Otherwise, input and
output from the existing one will de duplicated. 
If session is specified, all invocations of the um_monitor script with the same
session name share a single UM instance.
'''

from __future__ import print_function
import os,sys,subprocess,shutil,select,fcntl


def get_input_bytes(data_dir):
    with open(os.path.join(data_dir,'input'),'r') as input_file:
        fcntl.lockf(input_file,fcntl.LOCK_SH)
        buf=inputfile.read()
        fcntl.lockf(input_file,fcntl.LOCK_EX)
        input_file.truncate(0)
        fcntl.lockf(input_file,fcntl.LOCK_UN)
    return buf

def send_output_bytes(data,data_dir):
    with open(os.path.join(data_dir,'output'),'a') as output_file:
        fcntl.lockf(output_file,fcntl.LOCK_EX)
        output_file.truncate(0)
        output_file.write(data)
        fcntl.lockf(output_file,fcntl.LOCK_UN)

def run_UM(um,target,temp_dir,session):
    p=subprocess.Popen([um,target],stdin=PIPE,stdout=PIPE)
    #set stdout to non-blocking, so read() will not wait for EOF
    fl = fcntl.fcntl(p.stdout), fcntl.F_GETFL) #get current file flags
    fcntl.fcntl(p.stdout, fcntl.F_SETFL, fl | os.O_NONBLOCK) #set flags
    output_waiting=select.poll().register(p.stdout)
    #check if the process is still running
    while p.poll() is not None:
        #check if there are input bytes available
        in_bytes=get_input_bytes(temp_dir)
        p.stdin.write(in_bytes)
        while output_waiting.poll(timeout=1000):
            send_output_bytes(p.stdout.read(),tmp_dir)

def interact_UM(path):
    pass

def setup_dir(path):
    with open(os.path.join(path,'pidfile'),'w') as pidfile:
        print(os.getpid(),file=pidfile)
    open(os.path.join(path,'input'),'w').close()
    open(os.path.join(path,'ouput'),'w').close()


if __name__ == '__main__':
    if len(sys.argv) < 2 or len(sys.argv) > 3:
        print('Usage:',sys.argv[0],'um_file [session]',file=sys.stderr)
        exit()
    elif len(sys.argv) == 2:
        session=''
        lock_dir=os.path.join(sys.path[0],'lock')
    else:
        session=sys.argv[2]
        lock_dir=os.path.join(sys.path[0],'lock'+session)

    #try to get the lock
    try:
        os.mkdir(lock_dir)
        master=True
    except OSError:
        master=False
    
    if master:
        setup_dir(lock_dir)
        print('starting UM session',session,file=sys.stderr)
        um=os.path.join(sys.path[0],'um')
        run_UM(um,sys.argv[1],lock_dir,session)
        print('done with UM session',session,file=sys.stderr)
        shutil.rmdir(lock_dir)
    else:
        print('connecting to UM session',session,file=sys.stderr)
        interact_UM(lock_dir)
        print('done with UM session',session,file=sys.stderr)
